/* Settings.c generated by valac 0.36.7, the Vala compiler
 * generated from Settings.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <float.h>
#include <math.h>


#define GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE (granite_services_settings_serializable_get_type ())
#define GRANITE_SERVICES_SETTINGS_SERIALIZABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE, GraniteServicesSettingsSerializable))
#define GRANITE_SERVICES_IS_SETTINGS_SERIALIZABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE))
#define GRANITE_SERVICES_SETTINGS_SERIALIZABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE, GraniteServicesSettingsSerializableIface))

typedef struct _GraniteServicesSettingsSerializable GraniteServicesSettingsSerializable;
typedef struct _GraniteServicesSettingsSerializableIface GraniteServicesSettingsSerializableIface;

#define GRANITE_SERVICES_TYPE_SETTINGS (granite_services_settings_get_type ())
#define GRANITE_SERVICES_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettings))
#define GRANITE_SERVICES_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettingsClass))
#define GRANITE_SERVICES_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRANITE_SERVICES_TYPE_SETTINGS))
#define GRANITE_SERVICES_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRANITE_SERVICES_TYPE_SETTINGS))
#define GRANITE_SERVICES_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettingsClass))

typedef struct _GraniteServicesSettings GraniteServicesSettings;
typedef struct _GraniteServicesSettingsClass GraniteServicesSettingsClass;
typedef struct _GraniteServicesSettingsPrivate GraniteServicesSettingsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
enum  {
	GRANITE_SERVICES_SETTINGS_CHANGED_SIGNAL,
	GRANITE_SERVICES_SETTINGS_NUM_SIGNALS
};
static guint granite_services_settings_signals[GRANITE_SERVICES_SETTINGS_NUM_SIGNALS] = {0};

struct _GraniteServicesSettingsSerializableIface {
	GTypeInterface parent_iface;
	gchar* (*settings_serialize) (GraniteServicesSettingsSerializable* self);
	void (*settings_deserialize) (GraniteServicesSettingsSerializable* self, const gchar* s);
};

struct _GraniteServicesSettings {
	GObject parent_instance;
	GraniteServicesSettingsPrivate * priv;
};

struct _GraniteServicesSettingsClass {
	GObjectClass parent_class;
	void (*verify) (GraniteServicesSettings* self, const gchar* key);
};

struct _GraniteServicesSettingsPrivate {
	GSettings* _schema;
};


static gpointer granite_services_settings_parent_class = NULL;

GType granite_services_settings_serializable_get_type (void) G_GNUC_CONST;
gchar* granite_services_settings_serializable_settings_serialize (GraniteServicesSettingsSerializable* self);
void granite_services_settings_serializable_settings_deserialize (GraniteServicesSettingsSerializable* self, const gchar* s);
GType granite_services_settings_get_type (void) G_GNUC_CONST;
#define GRANITE_SERVICES_SETTINGS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettingsPrivate))
enum  {
	GRANITE_SERVICES_SETTINGS_0_PROPERTY,
	GRANITE_SERVICES_SETTINGS_SCHEMA_PROPERTY
};
static void granite_services_settings_stop_monitor (GraniteServicesSettings* self);
GraniteServicesSettings* granite_services_settings_construct (GType object_type, const gchar* schema);
GraniteServicesSettings* granite_services_settings_construct_with_backend (GType object_type, const gchar* schema, GSettingsBackend* backend);
GraniteServicesSettings* granite_services_settings_construct_with_backend_and_path (GType object_type, const gchar* schema, GSettingsBackend* backend, const gchar* path);
GraniteServicesSettings* granite_services_settings_construct_with_path (GType object_type, const gchar* schema, const gchar* path);
GSettings* granite_services_settings_get_schema (GraniteServicesSettings* self);
static void granite_services_settings_load_key (GraniteServicesSettings* self, const gchar* key);
static void _granite_services_settings_load_key_g_settings_changed (GSettings* _sender, const gchar* key, gpointer self);
static void granite_services_settings_start_monitor (GraniteServicesSettings* self);
static void granite_services_settings_handle_notify (GraniteServicesSettings* self, GObject* sender, GParamSpec* property);
static void _granite_services_settings_handle_notify_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void granite_services_settings_call_verify (GraniteServicesSettings* self, const gchar* key);
static void granite_services_settings_save_key (GraniteServicesSettings* self, const gchar* key);
static void granite_services_settings_handle_verify_notify (GraniteServicesSettings* self, GObject* sender, GParamSpec* property);
static void _granite_services_settings_handle_verify_notify_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
void granite_services_settings_verify (GraniteServicesSettings* self, const gchar* key);
static void granite_services_settings_real_verify (GraniteServicesSettings* self, const gchar* key);
static void granite_services_settings_set_schema (GraniteServicesSettings* self, GSettings* value);
static GObject * granite_services_settings_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void granite_services_settings_finalize (GObject * obj);
static void _vala_granite_services_settings_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_granite_services_settings_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


/**
         * Serializes the object into a string representation.
         *
         * @return the string representation of the object
         */
gchar* granite_services_settings_serializable_settings_serialize (GraniteServicesSettingsSerializable* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return GRANITE_SERVICES_SETTINGS_SERIALIZABLE_GET_INTERFACE (self)->settings_serialize (self);
}


/**
         * Un-serializes the object from a string representation.
         *
         * @param s the string representation of the object
         */
void granite_services_settings_serializable_settings_deserialize (GraniteServicesSettingsSerializable* self, const gchar* s) {
	g_return_if_fail (self != NULL);
	GRANITE_SERVICES_SETTINGS_SERIALIZABLE_GET_INTERFACE (self)->settings_deserialize (self, s);
}


static void granite_services_settings_serializable_base_init (GraniteServicesSettingsSerializableIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


/**
     * This interface is used by objects that need to be serialized in a Settings.
     * The object must have a string representation and provide these methods to
     * translate between the string and object representations.
     */
GType granite_services_settings_serializable_get_type (void) {
	static volatile gsize granite_services_settings_serializable_type_id__volatile = 0;
	if (g_once_init_enter (&granite_services_settings_serializable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GraniteServicesSettingsSerializableIface), (GBaseInitFunc) granite_services_settings_serializable_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType granite_services_settings_serializable_type_id;
		granite_services_settings_serializable_type_id = g_type_register_static (G_TYPE_INTERFACE, "GraniteServicesSettingsSerializable", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (granite_services_settings_serializable_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&granite_services_settings_serializable_type_id__volatile, granite_services_settings_serializable_type_id);
	}
	return granite_services_settings_serializable_type_id__volatile;
}


/**
         * Creates a new {@link Granite.Services.Settings} object for the supplied schema.
         *
         * @param schema the name of the schema to interact with
         */
GraniteServicesSettings* granite_services_settings_construct (GType object_type, const gchar* schema) {
	GraniteServicesSettings * self = NULL;
	const gchar* _tmp0_;
	GSettings* _tmp1_;
	GSettings* _tmp2_;
	g_return_val_if_fail (schema != NULL, NULL);
	_tmp0_ = schema;
	_tmp1_ = g_settings_new (_tmp0_);
	_tmp2_ = _tmp1_;
	self = (GraniteServicesSettings*) g_object_new (object_type, "schema", _tmp2_, NULL);
	_g_object_unref0 (_tmp2_);
	return self;
}


/**
         * Creates a new {@link Granite.Services.Settings} object for the supplied schema and {@link GLib.SettingsBackend}.
         *
         * @param schema the name of the schema to interact with
         * @param backend the desired backend to use
         */
GraniteServicesSettings* granite_services_settings_construct_with_backend (GType object_type, const gchar* schema, GSettingsBackend* backend) {
	GraniteServicesSettings * self = NULL;
	const gchar* _tmp0_;
	GSettingsBackend* _tmp1_;
	GSettings* _tmp2_;
	GSettings* _tmp3_;
	g_return_val_if_fail (schema != NULL, NULL);
	g_return_val_if_fail (backend != NULL, NULL);
	_tmp0_ = schema;
	_tmp1_ = backend;
	_tmp2_ = g_settings_new_with_backend (_tmp0_, _tmp1_);
	_tmp3_ = _tmp2_;
	self = (GraniteServicesSettings*) g_object_new (object_type, "schema", _tmp3_, NULL);
	_g_object_unref0 (_tmp3_);
	return self;
}


/**
         * Creates a new {@link Granite.Services.Settings} object for the supplied schema, {@link GLib.SettingsBackend}, and path.
         * 
         *
         * @param schema the name of the schema to interact with
         * @param backend the desired backend to use
         * @param path the path to use
         */
GraniteServicesSettings* granite_services_settings_construct_with_backend_and_path (GType object_type, const gchar* schema, GSettingsBackend* backend, const gchar* path) {
	GraniteServicesSettings * self = NULL;
	const gchar* _tmp0_;
	GSettingsBackend* _tmp1_;
	const gchar* _tmp2_;
	GSettings* _tmp3_;
	GSettings* _tmp4_;
	g_return_val_if_fail (schema != NULL, NULL);
	g_return_val_if_fail (backend != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = schema;
	_tmp1_ = backend;
	_tmp2_ = path;
	_tmp3_ = g_settings_new_with_backend_and_path (_tmp0_, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	self = (GraniteServicesSettings*) g_object_new (object_type, "schema", _tmp4_, NULL);
	_g_object_unref0 (_tmp4_);
	return self;
}


/**
         * Creates a new {@link Granite.Services.Settings} object for the supplied schema, and path.
         * 
         * You only need to do this if you want to directly create a settings object with a schema that
         * doesn't have a specified path of its own. That's quite rare.
         *
         * It is a programmer error to call this function for a schema that has an explicitly specified path.
         *
         * @param schema the name of the schema to interact with
         * @param path the path to use
         */
GraniteServicesSettings* granite_services_settings_construct_with_path (GType object_type, const gchar* schema, const gchar* path) {
	GraniteServicesSettings * self = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GSettings* _tmp2_;
	GSettings* _tmp3_;
	g_return_val_if_fail (schema != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = schema;
	_tmp1_ = path;
	_tmp2_ = g_settings_new_with_path (_tmp0_, _tmp1_);
	_tmp3_ = _tmp2_;
	self = (GraniteServicesSettings*) g_object_new (object_type, "schema", _tmp3_, NULL);
	_g_object_unref0 (_tmp3_);
	return self;
}


static void _granite_services_settings_load_key_g_settings_changed (GSettings* _sender, const gchar* key, gpointer self) {
	granite_services_settings_load_key ((GraniteServicesSettings*) self, key);
}


static void granite_services_settings_stop_monitor (GraniteServicesSettings* self) {
	GSettings* _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_schema;
	g_signal_parse_name ("changed", g_settings_get_type (), &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _granite_services_settings_load_key_g_settings_changed, self);
}


static void granite_services_settings_start_monitor (GraniteServicesSettings* self) {
	GSettings* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_schema;
	g_signal_connect_object (_tmp0_, "changed", (GCallback) _granite_services_settings_load_key_g_settings_changed, self, 0);
}


static void _granite_services_settings_handle_notify_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	granite_services_settings_handle_notify ((GraniteServicesSettings*) self, _sender, pspec);
}


static void granite_services_settings_handle_notify (GraniteServicesSettings* self, GObject* sender, GParamSpec* property) {
	guint _tmp0_;
	GParamSpec* _tmp1_;
	const gchar* _tmp2_;
	GParamSpec* _tmp3_;
	const gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	g_return_if_fail (property != NULL);
	g_signal_parse_name ("notify", G_TYPE_OBJECT, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _granite_services_settings_handle_notify_g_object_notify, self);
	_tmp1_ = property;
	_tmp2_ = _tmp1_->name;
	granite_services_settings_call_verify (self, _tmp2_);
	g_signal_connect_object ((GObject*) self, "notify", (GCallback) _granite_services_settings_handle_notify_g_object_notify, self, 0);
	_tmp3_ = property;
	_tmp4_ = _tmp3_->name;
	granite_services_settings_save_key (self, _tmp4_);
}


static void granite_services_settings_handle_verify_notify (GraniteServicesSettings* self, GObject* sender, GParamSpec* property) {
	GParamSpec* _tmp0_;
	const gchar* _tmp1_;
	GSettings* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	g_return_if_fail (property != NULL);
	_tmp0_ = property;
	_tmp1_ = _tmp0_->name;
	_tmp2_ = self->priv->_schema;
	g_object_get (_tmp2_, "schema", &_tmp3_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	g_warning ("Settings.vala:193: Key '%s' failed verification in schema '%s', changi" \
"ng value", _tmp1_, _tmp5_);
	_g_free0 (_tmp5_);
}


static void _granite_services_settings_handle_verify_notify_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	granite_services_settings_handle_verify_notify ((GraniteServicesSettings*) self, _sender, pspec);
}


static void granite_services_settings_call_verify (GraniteServicesSettings* self, const gchar* key) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	guint _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_signal_connect_object ((GObject*) self, "notify", (GCallback) _granite_services_settings_handle_verify_notify_g_object_notify, self, 0);
	_tmp0_ = key;
	granite_services_settings_verify (self, _tmp0_);
	_tmp1_ = key;
	g_signal_emit (self, granite_services_settings_signals[GRANITE_SERVICES_SETTINGS_CHANGED_SIGNAL], g_quark_from_string (_tmp1_));
	g_signal_parse_name ("notify", G_TYPE_OBJECT, &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _granite_services_settings_handle_verify_notify_g_object_notify, self);
}


/**
         * Verify the given key, changing the property if necessary. Refer to the example given for the class.
         *
         * @param key the key in question
         */
static void granite_services_settings_real_verify (GraniteServicesSettings* self, const gchar* key) {
	g_return_if_fail (key != NULL);
}


void granite_services_settings_verify (GraniteServicesSettings* self, const gchar* key) {
	g_return_if_fail (self != NULL);
	GRANITE_SERVICES_SETTINGS_GET_CLASS (self)->verify (self, key);
}


static gpointer _g_param_spec_ref0 (gpointer self) {
	return self ? g_param_spec_ref (self) : NULL;
}


static void granite_services_settings_load_key (GraniteServicesSettings* self, const gchar* key) {
	const gchar* _tmp0_;
	GObjectClass* obj_class = NULL;
	GType _tmp1_;
	GTypeClass* _tmp2_;
	GParamSpec* prop = NULL;
	GObjectClass* _tmp3_;
	const gchar* _tmp4_;
	GParamSpec* _tmp5_;
	GParamSpec* _tmp6_;
	GParamSpec* _tmp7_;
	guint _tmp8_;
	GType type = 0UL;
	GParamSpec* _tmp9_;
	GType _tmp10_;
	GValue val = {0};
	GType _tmp11_;
	GValue _tmp12_ = {0};
	GParamSpec* _tmp13_;
	const gchar* _tmp14_;
	GType _tmp15_;
	GParamSpec* _tmp16_;
	GType _tmp17_;
	const gchar* _tmp84_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_tmp0_ = key;
	if (g_strcmp0 (_tmp0_, "schema") == 0) {
		return;
	}
	_tmp1_ = G_TYPE_FROM_INSTANCE ((GObject*) self);
	_tmp2_ = g_type_class_ref (_tmp1_);
	obj_class = (GObjectClass*) _tmp2_;
	_tmp3_ = obj_class;
	_tmp4_ = key;
	_tmp5_ = g_object_class_find_property (_tmp3_, _tmp4_);
	_tmp6_ = _g_param_spec_ref0 (_tmp5_);
	prop = _tmp6_;
	_tmp7_ = prop;
	if (_tmp7_ == NULL) {
		_g_param_spec_unref0 (prop);
		_g_type_class_unref0 (obj_class);
		return;
	}
	g_signal_parse_name ("notify", G_TYPE_OBJECT, &_tmp8_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp8_, 0, NULL, (GCallback) _granite_services_settings_handle_notify_g_object_notify, self);
	_tmp9_ = prop;
	_tmp10_ = _tmp9_->value_type;
	type = _tmp10_;
	_tmp11_ = type;
	g_value_init (&_tmp12_, _tmp11_);
	val = _tmp12_;
	_tmp13_ = prop;
	_tmp14_ = _tmp13_->name;
	g_object_get_property ((GObject*) self, _tmp14_, &val);
	_tmp15_ = G_VALUE_TYPE (&val);
	_tmp16_ = prop;
	_tmp17_ = _tmp16_->value_type;
	if (_tmp15_ == _tmp17_) {
		GType _tmp18_;
		_tmp18_ = type;
		if (_tmp18_ == G_TYPE_INT) {
			GParamSpec* _tmp19_;
			const gchar* _tmp20_;
			GSettings* _tmp21_;
			const gchar* _tmp22_;
			gint _tmp23_;
			GValue _tmp24_ = {0};
			_tmp19_ = prop;
			_tmp20_ = _tmp19_->name;
			_tmp21_ = self->priv->_schema;
			_tmp22_ = key;
			_tmp23_ = g_settings_get_int (_tmp21_, _tmp22_);
			g_value_init (&_tmp24_, G_TYPE_INT);
			g_value_set_int (&_tmp24_, _tmp23_);
			g_object_set_property ((GObject*) self, _tmp20_, &_tmp24_);
			G_IS_VALUE (&_tmp24_) ? (g_value_unset (&_tmp24_), NULL) : NULL;
		} else {
			GType _tmp25_;
			_tmp25_ = type;
			if (_tmp25_ == G_TYPE_UINT) {
				GParamSpec* _tmp26_;
				const gchar* _tmp27_;
				GSettings* _tmp28_;
				const gchar* _tmp29_;
				guint _tmp30_;
				GValue _tmp31_ = {0};
				_tmp26_ = prop;
				_tmp27_ = _tmp26_->name;
				_tmp28_ = self->priv->_schema;
				_tmp29_ = key;
				_tmp30_ = g_settings_get_uint (_tmp28_, _tmp29_);
				g_value_init (&_tmp31_, G_TYPE_UINT);
				g_value_set_uint (&_tmp31_, _tmp30_);
				g_object_set_property ((GObject*) self, _tmp27_, &_tmp31_);
				G_IS_VALUE (&_tmp31_) ? (g_value_unset (&_tmp31_), NULL) : NULL;
			} else {
				GType _tmp32_;
				_tmp32_ = type;
				if (_tmp32_ == G_TYPE_DOUBLE) {
					GParamSpec* _tmp33_;
					const gchar* _tmp34_;
					GSettings* _tmp35_;
					const gchar* _tmp36_;
					gdouble _tmp37_;
					GValue _tmp38_ = {0};
					_tmp33_ = prop;
					_tmp34_ = _tmp33_->name;
					_tmp35_ = self->priv->_schema;
					_tmp36_ = key;
					_tmp37_ = g_settings_get_double (_tmp35_, _tmp36_);
					g_value_init (&_tmp38_, G_TYPE_DOUBLE);
					g_value_set_double (&_tmp38_, _tmp37_);
					g_object_set_property ((GObject*) self, _tmp34_, &_tmp38_);
					G_IS_VALUE (&_tmp38_) ? (g_value_unset (&_tmp38_), NULL) : NULL;
				} else {
					GType _tmp39_;
					_tmp39_ = type;
					if (_tmp39_ == G_TYPE_STRING) {
						GParamSpec* _tmp40_;
						const gchar* _tmp41_;
						GSettings* _tmp42_;
						const gchar* _tmp43_;
						gchar* _tmp44_;
						GValue _tmp45_ = {0};
						_tmp40_ = prop;
						_tmp41_ = _tmp40_->name;
						_tmp42_ = self->priv->_schema;
						_tmp43_ = key;
						_tmp44_ = g_settings_get_string (_tmp42_, _tmp43_);
						g_value_init (&_tmp45_, G_TYPE_STRING);
						g_value_take_string (&_tmp45_, _tmp44_);
						g_object_set_property ((GObject*) self, _tmp41_, &_tmp45_);
						G_IS_VALUE (&_tmp45_) ? (g_value_unset (&_tmp45_), NULL) : NULL;
					} else {
						GType _tmp46_;
						_tmp46_ = type;
						if (_tmp46_ == G_TYPE_STRV) {
							GParamSpec* _tmp47_;
							const gchar* _tmp48_;
							GSettings* _tmp49_;
							const gchar* _tmp50_;
							gchar** _tmp51_;
							gchar** _tmp52_;
							GValue _tmp53_ = {0};
							_tmp47_ = prop;
							_tmp48_ = _tmp47_->name;
							_tmp49_ = self->priv->_schema;
							_tmp50_ = key;
							_tmp52_ = _tmp51_ = g_settings_get_strv (_tmp49_, _tmp50_);
							g_value_init (&_tmp53_, G_TYPE_STRV);
							g_value_take_boxed (&_tmp53_, _tmp52_);
							g_object_set_property ((GObject*) self, _tmp48_, &_tmp53_);
							G_IS_VALUE (&_tmp53_) ? (g_value_unset (&_tmp53_), NULL) : NULL;
						} else {
							GType _tmp54_;
							_tmp54_ = type;
							if (_tmp54_ == G_TYPE_BOOLEAN) {
								GParamSpec* _tmp55_;
								const gchar* _tmp56_;
								GSettings* _tmp57_;
								const gchar* _tmp58_;
								gboolean _tmp59_;
								GValue _tmp60_ = {0};
								_tmp55_ = prop;
								_tmp56_ = _tmp55_->name;
								_tmp57_ = self->priv->_schema;
								_tmp58_ = key;
								_tmp59_ = g_settings_get_boolean (_tmp57_, _tmp58_);
								g_value_init (&_tmp60_, G_TYPE_BOOLEAN);
								g_value_set_boolean (&_tmp60_, _tmp59_);
								g_object_set_property ((GObject*) self, _tmp56_, &_tmp60_);
								G_IS_VALUE (&_tmp60_) ? (g_value_unset (&_tmp60_), NULL) : NULL;
							} else {
								GType _tmp61_;
								gboolean _tmp62_;
								_tmp61_ = type;
								_tmp62_ = G_TYPE_IS_ENUM (_tmp61_);
								if (_tmp62_) {
									GParamSpec* _tmp63_;
									const gchar* _tmp64_;
									GSettings* _tmp65_;
									const gchar* _tmp66_;
									gint _tmp67_;
									GValue _tmp68_ = {0};
									_tmp63_ = prop;
									_tmp64_ = _tmp63_->name;
									_tmp65_ = self->priv->_schema;
									_tmp66_ = key;
									_tmp67_ = g_settings_get_enum (_tmp65_, _tmp66_);
									g_value_init (&_tmp68_, G_TYPE_INT);
									g_value_set_int (&_tmp68_, _tmp67_);
									g_object_set_property ((GObject*) self, _tmp64_, &_tmp68_);
									G_IS_VALUE (&_tmp68_) ? (g_value_unset (&_tmp68_), NULL) : NULL;
								}
							}
						}
					}
				}
			}
		}
	} else {
		GType _tmp69_;
		gboolean _tmp70_;
		_tmp69_ = type;
		_tmp70_ = g_type_is_a (_tmp69_, GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE);
		if (_tmp70_) {
			const gchar* _tmp71_;
			GObject* _tmp72_;
			GSettings* _tmp73_;
			const gchar* _tmp74_;
			gchar* _tmp75_;
			gchar* _tmp76_;
			_tmp71_ = key;
			g_object_get_property ((GObject*) self, _tmp71_, &val);
			_tmp72_ = g_value_get_object (&val);
			_tmp73_ = self->priv->_schema;
			_tmp74_ = key;
			_tmp75_ = g_settings_get_string (_tmp73_, _tmp74_);
			_tmp76_ = _tmp75_;
			granite_services_settings_serializable_settings_deserialize (G_TYPE_CHECK_INSTANCE_TYPE (_tmp72_, GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE) ? ((GraniteServicesSettingsSerializable*) _tmp72_) : NULL, _tmp76_);
			_g_free0 (_tmp76_);
			g_signal_connect_object ((GObject*) self, "notify", (GCallback) _granite_services_settings_handle_notify_g_object_notify, self, 0);
			G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
			_g_param_spec_unref0 (prop);
			_g_type_class_unref0 (obj_class);
			return;
		} else {
			GType _tmp77_;
			const gchar* _tmp78_;
			const gchar* _tmp79_;
			GSettings* _tmp80_;
			gchar* _tmp81_;
			gchar* _tmp82_;
			gchar* _tmp83_;
			_tmp77_ = type;
			_tmp78_ = g_type_name (_tmp77_);
			_tmp79_ = key;
			_tmp80_ = self->priv->_schema;
			g_object_get (_tmp80_, "schema", &_tmp81_, NULL);
			_tmp82_ = _tmp81_;
			_tmp83_ = _tmp82_;
			g_debug ("Settings.vala:255: Unsupported settings type '%s' for key '%s' in sche" \
"ma '%s'", _tmp78_, _tmp79_, _tmp83_);
			_g_free0 (_tmp83_);
			g_signal_connect_object ((GObject*) self, "notify", (GCallback) _granite_services_settings_handle_notify_g_object_notify, self, 0);
			G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
			_g_param_spec_unref0 (prop);
			_g_type_class_unref0 (obj_class);
			return;
		}
	}
	_tmp84_ = key;
	granite_services_settings_call_verify (self, _tmp84_);
	g_signal_connect_object ((GObject*) self, "notify", (GCallback) _granite_services_settings_handle_notify_g_object_notify, self, 0);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	_g_param_spec_unref0 (prop);
	_g_type_class_unref0 (obj_class);
}


static void granite_services_settings_save_key (GraniteServicesSettings* self, const gchar* key) {
	const gchar* _tmp0_;
	GObjectClass* obj_class = NULL;
	GType _tmp1_;
	GTypeClass* _tmp2_;
	GParamSpec* prop = NULL;
	GObjectClass* _tmp3_;
	const gchar* _tmp4_;
	GParamSpec* _tmp5_;
	GParamSpec* _tmp6_;
	GParamSpec* _tmp7_;
	gboolean success = FALSE;
	guint _tmp8_;
	GType type = 0UL;
	GParamSpec* _tmp9_;
	GType _tmp10_;
	GValue val = {0};
	GType _tmp11_;
	GValue _tmp12_ = {0};
	GParamSpec* _tmp13_;
	const gchar* _tmp14_;
	GType _tmp15_;
	GParamSpec* _tmp16_;
	GType _tmp17_;
	gboolean _tmp103_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_tmp0_ = key;
	if (g_strcmp0 (_tmp0_, "schema") == 0) {
		return;
	}
	_tmp1_ = G_TYPE_FROM_INSTANCE ((GObject*) self);
	_tmp2_ = g_type_class_ref (_tmp1_);
	obj_class = (GObjectClass*) _tmp2_;
	_tmp3_ = obj_class;
	_tmp4_ = key;
	_tmp5_ = g_object_class_find_property (_tmp3_, _tmp4_);
	_tmp6_ = _g_param_spec_ref0 (_tmp5_);
	prop = _tmp6_;
	_tmp7_ = prop;
	if (_tmp7_ == NULL) {
		_g_param_spec_unref0 (prop);
		_g_type_class_unref0 (obj_class);
		return;
	}
	success = TRUE;
	granite_services_settings_stop_monitor (self);
	g_signal_parse_name ("notify", G_TYPE_OBJECT, &_tmp8_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp8_, 0, NULL, (GCallback) _granite_services_settings_handle_notify_g_object_notify, self);
	_tmp9_ = prop;
	_tmp10_ = _tmp9_->value_type;
	type = _tmp10_;
	_tmp11_ = type;
	g_value_init (&_tmp12_, _tmp11_);
	val = _tmp12_;
	_tmp13_ = prop;
	_tmp14_ = _tmp13_->name;
	g_object_get_property ((GObject*) self, _tmp14_, &val);
	_tmp15_ = G_VALUE_TYPE (&val);
	_tmp16_ = prop;
	_tmp17_ = _tmp16_->value_type;
	if (_tmp15_ == _tmp17_) {
		GType _tmp18_;
		_tmp18_ = type;
		if (_tmp18_ == G_TYPE_INT) {
			gint _tmp19_;
			GSettings* _tmp20_;
			const gchar* _tmp21_;
			gint _tmp22_;
			_tmp19_ = g_value_get_int (&val);
			_tmp20_ = self->priv->_schema;
			_tmp21_ = key;
			_tmp22_ = g_settings_get_int (_tmp20_, _tmp21_);
			if (_tmp19_ != _tmp22_) {
				GSettings* _tmp23_;
				const gchar* _tmp24_;
				gint _tmp25_;
				gboolean _tmp26_;
				_tmp23_ = self->priv->_schema;
				_tmp24_ = key;
				_tmp25_ = g_value_get_int (&val);
				_tmp26_ = g_settings_set_int (_tmp23_, _tmp24_, _tmp25_);
				success = _tmp26_;
			}
		} else {
			GType _tmp27_;
			_tmp27_ = type;
			if (_tmp27_ == G_TYPE_UINT) {
				guint _tmp28_;
				GSettings* _tmp29_;
				const gchar* _tmp30_;
				guint _tmp31_;
				_tmp28_ = g_value_get_uint (&val);
				_tmp29_ = self->priv->_schema;
				_tmp30_ = key;
				_tmp31_ = g_settings_get_uint (_tmp29_, _tmp30_);
				if (_tmp28_ != _tmp31_) {
					GSettings* _tmp32_;
					const gchar* _tmp33_;
					guint _tmp34_;
					gboolean _tmp35_;
					_tmp32_ = self->priv->_schema;
					_tmp33_ = key;
					_tmp34_ = g_value_get_uint (&val);
					_tmp35_ = g_settings_set_uint (_tmp32_, _tmp33_, _tmp34_);
					success = _tmp35_;
				}
			} else {
				GType _tmp36_;
				_tmp36_ = type;
				if (_tmp36_ == G_TYPE_DOUBLE) {
					gdouble _tmp37_;
					GSettings* _tmp38_;
					const gchar* _tmp39_;
					gdouble _tmp40_;
					_tmp37_ = g_value_get_double (&val);
					_tmp38_ = self->priv->_schema;
					_tmp39_ = key;
					_tmp40_ = g_settings_get_double (_tmp38_, _tmp39_);
					if (_tmp37_ != _tmp40_) {
						GSettings* _tmp41_;
						const gchar* _tmp42_;
						gdouble _tmp43_;
						gboolean _tmp44_;
						_tmp41_ = self->priv->_schema;
						_tmp42_ = key;
						_tmp43_ = g_value_get_double (&val);
						_tmp44_ = g_settings_set_double (_tmp41_, _tmp42_, _tmp43_);
						success = _tmp44_;
					}
				} else {
					GType _tmp45_;
					_tmp45_ = type;
					if (_tmp45_ == G_TYPE_STRING) {
						const gchar* _tmp46_;
						GSettings* _tmp47_;
						const gchar* _tmp48_;
						gchar* _tmp49_;
						gchar* _tmp50_;
						gboolean _tmp51_;
						_tmp46_ = g_value_get_string (&val);
						_tmp47_ = self->priv->_schema;
						_tmp48_ = key;
						_tmp49_ = g_settings_get_string (_tmp47_, _tmp48_);
						_tmp50_ = _tmp49_;
						_tmp51_ = g_strcmp0 (_tmp46_, _tmp50_) != 0;
						_g_free0 (_tmp50_);
						if (_tmp51_) {
							GSettings* _tmp52_;
							const gchar* _tmp53_;
							const gchar* _tmp54_;
							gboolean _tmp55_;
							_tmp52_ = self->priv->_schema;
							_tmp53_ = key;
							_tmp54_ = g_value_get_string (&val);
							_tmp55_ = g_settings_set_string (_tmp52_, _tmp53_, _tmp54_);
							success = _tmp55_;
						}
					} else {
						GType _tmp56_;
						_tmp56_ = type;
						if (_tmp56_ == G_TYPE_STRV) {
							gchar** strings = NULL;
							gint strings_length1;
							gint _strings_size_;
							const gchar* _tmp57_;
							gchar** _tmp58_;
							gint _tmp58__length1;
							GSettings* _tmp59_;
							const gchar* _tmp60_;
							gchar** _tmp61_;
							gchar** _tmp62_;
							gchar** _tmp63_;
							gint _tmp63__length1;
							gboolean _tmp64_;
							strings = NULL;
							strings_length1 = 0;
							_strings_size_ = strings_length1;
							_tmp57_ = key;
							g_object_get ((GObject*) self, _tmp57_, &strings, NULL);
							_tmp58_ = strings;
							_tmp58__length1 = strings_length1;
							_tmp59_ = self->priv->_schema;
							_tmp60_ = key;
							_tmp62_ = _tmp61_ = g_settings_get_strv (_tmp59_, _tmp60_);
							_tmp63_ = _tmp62_;
							_tmp63__length1 = _vala_array_length (_tmp61_);
							_tmp64_ = _tmp58_ != _tmp63_;
							_tmp63_ = (_vala_array_free (_tmp63_, _tmp63__length1, (GDestroyNotify) g_free), NULL);
							if (_tmp64_) {
								GSettings* _tmp65_;
								const gchar* _tmp66_;
								gchar** _tmp67_;
								gint _tmp67__length1;
								gboolean _tmp68_;
								_tmp65_ = self->priv->_schema;
								_tmp66_ = key;
								_tmp67_ = strings;
								_tmp67__length1 = strings_length1;
								_tmp68_ = g_settings_set_strv (_tmp65_, _tmp66_, _tmp67_);
								success = _tmp68_;
							}
							strings = (_vala_array_free (strings, strings_length1, (GDestroyNotify) g_free), NULL);
						} else {
							GType _tmp69_;
							_tmp69_ = type;
							if (_tmp69_ == G_TYPE_BOOLEAN) {
								gboolean _tmp70_;
								GSettings* _tmp71_;
								const gchar* _tmp72_;
								gboolean _tmp73_;
								_tmp70_ = g_value_get_boolean (&val);
								_tmp71_ = self->priv->_schema;
								_tmp72_ = key;
								_tmp73_ = g_settings_get_boolean (_tmp71_, _tmp72_);
								if (_tmp70_ != _tmp73_) {
									GSettings* _tmp74_;
									const gchar* _tmp75_;
									gboolean _tmp76_;
									gboolean _tmp77_;
									_tmp74_ = self->priv->_schema;
									_tmp75_ = key;
									_tmp76_ = g_value_get_boolean (&val);
									_tmp77_ = g_settings_set_boolean (_tmp74_, _tmp75_, _tmp76_);
									success = _tmp77_;
								}
							} else {
								GType _tmp78_;
								gboolean _tmp79_;
								_tmp78_ = type;
								_tmp79_ = G_TYPE_IS_ENUM (_tmp78_);
								if (_tmp79_) {
									gint _tmp80_;
									GSettings* _tmp81_;
									const gchar* _tmp82_;
									gint _tmp83_;
									_tmp80_ = g_value_get_enum (&val);
									_tmp81_ = self->priv->_schema;
									_tmp82_ = key;
									_tmp83_ = g_settings_get_enum (_tmp81_, _tmp82_);
									if (_tmp80_ != _tmp83_) {
										GSettings* _tmp84_;
										const gchar* _tmp85_;
										gint _tmp86_;
										gboolean _tmp87_;
										_tmp84_ = self->priv->_schema;
										_tmp85_ = key;
										_tmp86_ = g_value_get_enum (&val);
										_tmp87_ = g_settings_set_enum (_tmp84_, _tmp85_, _tmp86_);
										success = _tmp87_;
									}
								}
							}
						}
					}
				}
			}
		}
	} else {
		GType _tmp88_;
		gboolean _tmp89_;
		_tmp88_ = type;
		_tmp89_ = g_type_is_a (_tmp88_, GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE);
		if (_tmp89_) {
			GSettings* _tmp90_;
			const gchar* _tmp91_;
			GObject* _tmp92_;
			gchar* _tmp93_;
			gchar* _tmp94_;
			gboolean _tmp95_;
			_tmp90_ = self->priv->_schema;
			_tmp91_ = key;
			_tmp92_ = g_value_get_object (&val);
			_tmp93_ = granite_services_settings_serializable_settings_serialize (G_TYPE_CHECK_INSTANCE_TYPE (_tmp92_, GRANITE_SERVICES_TYPE_SETTINGS_SERIALIZABLE) ? ((GraniteServicesSettingsSerializable*) _tmp92_) : NULL);
			_tmp94_ = _tmp93_;
			_tmp95_ = g_settings_set_string (_tmp90_, _tmp91_, _tmp94_);
			success = _tmp95_;
			_g_free0 (_tmp94_);
		} else {
			GType _tmp96_;
			const gchar* _tmp97_;
			const gchar* _tmp98_;
			GSettings* _tmp99_;
			gchar* _tmp100_;
			gchar* _tmp101_;
			gchar* _tmp102_;
			_tmp96_ = type;
			_tmp97_ = g_type_name (_tmp96_);
			_tmp98_ = key;
			_tmp99_ = self->priv->_schema;
			g_object_get (_tmp99_, "schema", &_tmp100_, NULL);
			_tmp101_ = _tmp100_;
			_tmp102_ = _tmp101_;
			g_debug ("Settings.vala:321: Unsupported settings type '%s' for key '%s' in sche" \
"ma '%s'", _tmp97_, _tmp98_, _tmp102_);
			_g_free0 (_tmp102_);
		}
	}
	_tmp103_ = success;
	if (!_tmp103_) {
		const gchar* _tmp104_;
		_tmp104_ = key;
		g_warning ("Settings.vala:324: Key '%s' could not be written to.", _tmp104_);
	}
	g_signal_connect_object ((GObject*) self, "notify", (GCallback) _granite_services_settings_handle_notify_g_object_notify, self, 0);
	granite_services_settings_start_monitor (self);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	_g_param_spec_unref0 (prop);
	_g_type_class_unref0 (obj_class);
}


GSettings* granite_services_settings_get_schema (GraniteServicesSettings* self) {
	GSettings* result;
	GSettings* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_schema;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void granite_services_settings_set_schema (GraniteServicesSettings* self, GSettings* value) {
	g_return_if_fail (self != NULL);
	if (granite_services_settings_get_schema (self) != value) {
		GSettings* _tmp0_;
		GSettings* _tmp1_;
		_tmp0_ = value;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_g_object_unref0 (self->priv->_schema);
		self->priv->_schema = _tmp1_;
		g_object_notify ((GObject *) self, "schema");
	}
}


static GObject * granite_services_settings_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GraniteServicesSettings * self;
	GSettings* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	GObjectClass* obj_class = NULL;
	GType _tmp4_;
	GTypeClass* _tmp5_;
	GParamSpec** properties = NULL;
	GObjectClass* _tmp6_;
	guint _tmp7_;
	GParamSpec** _tmp8_;
	gint properties_length1;
	gint _properties_size_;
	GParamSpec** _tmp9_;
	gint _tmp9__length1;
	parent_class = G_OBJECT_CLASS (granite_services_settings_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettings);
	_tmp0_ = self->priv->_schema;
	g_object_get (_tmp0_, "schema", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	g_debug ("Settings.vala:158: Loading settings from schema '%s'", _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = G_TYPE_FROM_INSTANCE ((GObject*) self);
	_tmp5_ = g_type_class_ref (_tmp4_);
	obj_class = (GObjectClass*) _tmp5_;
	_tmp6_ = obj_class;
	_tmp8_ = g_object_class_list_properties (_tmp6_, &_tmp7_);
	properties = _tmp8_;
	properties_length1 = _tmp7_;
	_properties_size_ = properties_length1;
	_tmp9_ = properties;
	_tmp9__length1 = properties_length1;
	{
		GParamSpec** prop_collection = NULL;
		gint prop_collection_length1 = 0;
		gint _prop_collection_size_ = 0;
		gint prop_it = 0;
		prop_collection = _tmp9_;
		prop_collection_length1 = _tmp9__length1;
		for (prop_it = 0; prop_it < _tmp9__length1; prop_it = prop_it + 1) {
			GParamSpec* prop = NULL;
			prop = prop_collection[prop_it];
			{
				GParamSpec* _tmp10_;
				const gchar* _tmp11_;
				_tmp10_ = prop;
				_tmp11_ = _tmp10_->name;
				granite_services_settings_load_key (self, _tmp11_);
			}
		}
	}
	granite_services_settings_start_monitor (self);
	properties = (g_free (properties), NULL);
	_g_type_class_unref0 (obj_class);
	return obj;
}


static void granite_services_settings_class_init (GraniteServicesSettingsClass * klass) {
	granite_services_settings_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GraniteServicesSettingsPrivate));
	((GraniteServicesSettingsClass *) klass)->verify = (void (*) (GraniteServicesSettings *, const gchar*)) granite_services_settings_real_verify;
	G_OBJECT_CLASS (klass)->get_property = _vala_granite_services_settings_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_granite_services_settings_set_property;
	G_OBJECT_CLASS (klass)->constructor = granite_services_settings_constructor;
	G_OBJECT_CLASS (klass)->finalize = granite_services_settings_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GRANITE_SERVICES_SETTINGS_SCHEMA_PROPERTY, g_param_spec_object ("schema", "schema", "schema", g_settings_get_type (), G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	/**
	         * This signal is to be used in place of the standard {@link GLib.Object.notify} signal.
	         *
	         * This signal ''only'' emits after a property's value was verified.
	         *
	         * Note that in the case where a property was set to an invalid value,
	         * (and thus, sanitized to a valid value), the {@link GLib.Object.notify} signal will emit 
	         * twice: once with the invalid value and once with the sanitized value.
	         */
	granite_services_settings_signals[GRANITE_SERVICES_SETTINGS_CHANGED_SIGNAL] = g_signal_new ("changed", GRANITE_SERVICES_TYPE_SETTINGS, G_SIGNAL_RUN_FIRST | G_SIGNAL_DETAILED | G_SIGNAL_NO_RECURSE | G_SIGNAL_ACTION | G_SIGNAL_NO_HOOKS, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void granite_services_settings_instance_init (GraniteServicesSettings * self) {
	self->priv = GRANITE_SERVICES_SETTINGS_GET_PRIVATE (self);
}


static void granite_services_settings_finalize (GObject * obj) {
	GraniteServicesSettings * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettings);
	granite_services_settings_stop_monitor (self);
	_g_object_unref0 (self->priv->_schema);
	G_OBJECT_CLASS (granite_services_settings_parent_class)->finalize (obj);
}


/**
     * Class for interacting with an internal {@link GLib.Settings} using native Vala properties.
     * Clients of this class should not connect to the {@link GLib.Object.notify} signal.
     * Instead, they should connect to the {@link Granite.Services.Settings.changed} signal.
     *
     * For example, if a developer wanted to interact with desktop.Wallpaper's (http:/www.launchpad.net/pantheon-wallpaper) schema,
     * this is what his/her subclass might look like:
     *
     * {{{
     *    public class WallpaperSettings : Granite.Services.Settings {
     *    
     *        public PictureMode picture_mode { get; set; }
     *    
     *        public string picture_path { get; set; }
     *    
     *        public string background_color { get; set; }
     *    
     *        public WallpaperSettings () {
     *            base ("desktop.Wallpaper");
     *        }
     *    
     *        protected override void verify (string key) {
     *    
     *            switch (key) {
     *    
     *                case "background-color":
     *                    Gdk.Color bg;
     *                    if (!Gdk.Color.parse (background_color, out bg))
     *                        background_color = "#000000";
     *                    break;
     *            }
     *        }
     *    
     *    }
     * }}}
     *
     * Keep in mind that the developer must define his/her enums to match the schema's.
     * 
     * The following is a simplified explanation of how this library works:
*
     *  1. Any subclass looks at all properties it contains, and loads their initial values from the keys they represent.
     *     Because Vala properties are stored as GLib properties, the string representation of a property replaces underscores with
     *     hyphens (i.e. property_name becomes "property-name"). This is how this library knows which keys to load from. If the key
     *     does not exist, it will result in a fatal error.
     *  1. When a property of the subclass changes, the library will first verify the data before emitting a changed signal. If necessary,
     *     the library will change the value of the property while verifying.
     *     This is why developers should only act upon emissions of the changed () signal and never the native {@link GLib.Object.notify} signal.
     *  1. When the corresponding key of one of the properties of the subclass changes, it will also verify the data and change it, if necessary,
     *     before loading it into as the corresponding property's value.
     */
GType granite_services_settings_get_type (void) {
	static volatile gsize granite_services_settings_type_id__volatile = 0;
	if (g_once_init_enter (&granite_services_settings_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GraniteServicesSettingsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) granite_services_settings_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GraniteServicesSettings), 0, (GInstanceInitFunc) granite_services_settings_instance_init, NULL };
		GType granite_services_settings_type_id;
		granite_services_settings_type_id = g_type_register_static (G_TYPE_OBJECT, "GraniteServicesSettings", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&granite_services_settings_type_id__volatile, granite_services_settings_type_id);
	}
	return granite_services_settings_type_id__volatile;
}


static void _vala_granite_services_settings_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GraniteServicesSettings * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettings);
	switch (property_id) {
		case GRANITE_SERVICES_SETTINGS_SCHEMA_PROPERTY:
		g_value_set_object (value, granite_services_settings_get_schema (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_granite_services_settings_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GraniteServicesSettings * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GRANITE_SERVICES_TYPE_SETTINGS, GraniteServicesSettings);
	switch (property_id) {
		case GRANITE_SERVICES_SETTINGS_SCHEMA_PROPERTY:
		granite_services_settings_set_schema (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



