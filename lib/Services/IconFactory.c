/* IconFactory.c generated by valac 0.36.7, the Vala compiler
 * generated from IconFactory.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define GRANITE_SERVICES_TYPE_ICON_FACTORY (granite_services_icon_factory_get_type ())
#define GRANITE_SERVICES_ICON_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRANITE_SERVICES_TYPE_ICON_FACTORY, GraniteServicesIconFactory))
#define GRANITE_SERVICES_ICON_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRANITE_SERVICES_TYPE_ICON_FACTORY, GraniteServicesIconFactoryClass))
#define GRANITE_SERVICES_IS_ICON_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRANITE_SERVICES_TYPE_ICON_FACTORY))
#define GRANITE_SERVICES_IS_ICON_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRANITE_SERVICES_TYPE_ICON_FACTORY))
#define GRANITE_SERVICES_ICON_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRANITE_SERVICES_TYPE_ICON_FACTORY, GraniteServicesIconFactoryClass))

typedef struct _GraniteServicesIconFactory GraniteServicesIconFactory;
typedef struct _GraniteServicesIconFactoryClass GraniteServicesIconFactoryClass;
typedef struct _GraniteServicesIconFactoryPrivate GraniteServicesIconFactoryPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gtk_icon_info_free0(var) ((var == NULL) ? NULL : (var = (gtk_icon_info_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _GraniteServicesIconFactory {
	GObject parent_instance;
	GraniteServicesIconFactoryPrivate * priv;
};

struct _GraniteServicesIconFactoryClass {
	GObjectClass parent_class;
};

struct _GraniteServicesIconFactoryPrivate {
	GtkIconTheme* icon_theme;
};


extern GraniteServicesIconFactory* granite_services_icon_factory;
GraniteServicesIconFactory* granite_services_icon_factory = NULL;
static gpointer granite_services_icon_factory_parent_class = NULL;

GType granite_services_icon_factory_get_type (void) G_GNUC_CONST;
#define GRANITE_SERVICES_ICON_FACTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GRANITE_SERVICES_TYPE_ICON_FACTORY, GraniteServicesIconFactoryPrivate))
enum  {
	GRANITE_SERVICES_ICON_FACTORY_0_PROPERTY
};
GraniteServicesIconFactory* granite_services_icon_factory_new (void);
GraniteServicesIconFactory* granite_services_icon_factory_construct (GType object_type);
GraniteServicesIconFactory* granite_services_icon_factory_get_default (void);
GdkPixbuf* granite_services_icon_factory_load_symbolic_icon_from_gicon (GraniteServicesIconFactory* self, GtkStyleContext* style, GIcon* gicon, gint size);
GdkPixbuf* granite_services_icon_factory_load_symbolic_icon (GraniteServicesIconFactory* self, GtkStyleContext* style, const gchar* iconname, gint size);
static void granite_services_icon_factory_finalize (GObject * obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GraniteServicesIconFactory* granite_services_icon_factory_construct (GType object_type) {
	GraniteServicesIconFactory * self = NULL;
	GtkIconTheme* _tmp0_;
	GtkIconTheme* _tmp1_;
	self = (GraniteServicesIconFactory*) g_object_new (object_type, NULL);
	_tmp0_ = gtk_icon_theme_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->icon_theme);
	self->priv->icon_theme = _tmp1_;
	return self;
}


GraniteServicesIconFactory* granite_services_icon_factory_new (void) {
	return granite_services_icon_factory_construct (GRANITE_SERVICES_TYPE_ICON_FACTORY);
}


GraniteServicesIconFactory* granite_services_icon_factory_get_default (void) {
	GraniteServicesIconFactory* result = NULL;
	GraniteServicesIconFactory* _tmp0_;
	GraniteServicesIconFactory* _tmp3_;
	GraniteServicesIconFactory* _tmp4_;
	GraniteServicesIconFactory* _tmp5_;
	_tmp0_ = granite_services_icon_factory;
	if (_tmp0_ != NULL) {
		GraniteServicesIconFactory* _tmp1_;
		GraniteServicesIconFactory* _tmp2_;
		_tmp1_ = granite_services_icon_factory;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = granite_services_icon_factory_new ();
	_g_object_unref0 (granite_services_icon_factory);
	granite_services_icon_factory = _tmp3_;
	_tmp4_ = granite_services_icon_factory;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	result = _tmp5_;
	return result;
}


/**
         * Attempts to load a symbolic icon for the given {@link Glib.Icon} 
         * with graceful fallback on the non-symbolic variant if the symbolic one
         * does not exist.
         * 
         * Note that the resulting pixbuf may not be exactly the requested size;
         * an icon theme may have icons that differ slightly from their nominal sizes,
         * and in addition GTK+ will avoid scaling icons that it considers sufficiently close
         * to the requested size or for which the source image would have to be scaled up too far
         * (this maintains sharpness).
         *
         * @return a {@link Gdk.Pixbuf} with the rendered icon; this may be a newly created icon
         * or a new reference to an internal icon, so you must not modify the icon.
         * Returns null if the icon was not found in the theme hierarchy.
         */
GdkPixbuf* granite_services_icon_factory_load_symbolic_icon_from_gicon (GraniteServicesIconFactory* self, GtkStyleContext* style, GIcon* gicon, gint size) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* px = NULL;
	GtkIconInfo* icon_info = NULL;
	GtkIconTheme* _tmp0_;
	GIcon* _tmp1_;
	gint _tmp2_;
	GtkIconInfo* _tmp3_;
	GtkIconInfo* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (style != NULL, NULL);
	g_return_val_if_fail (gicon != NULL, NULL);
	px = NULL;
	_tmp0_ = self->priv->icon_theme;
	_tmp1_ = gicon;
	_tmp2_ = size;
	_tmp3_ = gtk_icon_theme_lookup_by_gicon (_tmp0_, _tmp1_, _tmp2_, GTK_ICON_LOOKUP_GENERIC_FALLBACK);
	icon_info = _tmp3_;
	_tmp4_ = icon_info;
	if (_tmp4_ == NULL) {
		result = NULL;
		_gtk_icon_info_free0 (icon_info);
		_g_object_unref0 (px);
		return result;
	}
	{
		GdkPixbuf* _tmp5_ = NULL;
		GtkIconInfo* _tmp6_;
		GtkStyleContext* _tmp7_;
		GdkPixbuf* _tmp8_;
		GdkPixbuf* _tmp9_;
		_tmp6_ = icon_info;
		_tmp7_ = style;
		_tmp8_ = gtk_icon_info_load_symbolic_for_context (_tmp6_, _tmp7_, NULL, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch16_g_error;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		_g_object_unref0 (px);
		px = _tmp9_;
		_g_object_unref0 (_tmp5_);
	}
	goto __finally16;
	__catch16_g_error:
	{
		GError* err = NULL;
		FILE* _tmp10_;
		GError* _tmp11_;
		const gchar* _tmp12_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp10_ = stderr;
		_tmp11_ = err;
		_tmp12_ = _tmp11_->message;
		fprintf (_tmp10_, "Unable to load symbolic icon: %s", _tmp12_);
		_g_error_free0 (err);
	}
	__finally16:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_gtk_icon_info_free0 (icon_info);
		_g_object_unref0 (px);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = px;
	_gtk_icon_info_free0 (icon_info);
	return result;
}


/**
         * Loads a symbolic icon for the given icon name with a better chance
         * for loading a symbolic icon in case of fallback than with {@link Gtk.IconTheme.load_icon}
         * 
         * Note that the resulting pixbuf may not be exactly the requested size;
         * an icon theme may have icons that differ slightly from their nominal sizes,
         * and in addition GTK+ will avoid scaling icons that it considers sufficiently close
         * to the requested size or for which the source image would have to be scaled up too far
         * (this maintains sharpness).
         * 
         * Due to the way {@link Gtk.IconLookupFlags.GENERIC_FALLBACK} works, Gtk readily
         * falls back to the non-symbolic icon if the exact match for the provided name is not found,
         * and only after that fails tries to look up alternative names of the icon itself.
         * This function uses the same mechanism, but looks up the symbolic icon for the
         * name chosen after all the fallbacks, and returns the symbolic one if it's present.
         * This gives a better chance of getting a symbolic icon in case of fallbacks than
         * when using {@link Gtk.IconTheme.load_icon}
         * 
         * @return a {@link Gdk.Pixbuf} with the rendered icon; this may be a newly created icon
         * or a new reference to an internal icon, so you must not modify the icon.
         * Returns null if the icon was not found in the theme hierarchy.
         */
GdkPixbuf* granite_services_icon_factory_load_symbolic_icon (GraniteServicesIconFactory* self, GtkStyleContext* style, const gchar* iconname, gint size) {
	GdkPixbuf* result = NULL;
	GThemedIcon* themed_icon = NULL;
	const gchar* _tmp0_;
	GThemedIcon* _tmp1_;
	GtkStyleContext* _tmp2_;
	gint _tmp3_;
	GdkPixbuf* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (style != NULL, NULL);
	g_return_val_if_fail (iconname != NULL, NULL);
	_tmp0_ = iconname;
	_tmp1_ = (GThemedIcon*) g_themed_icon_new_with_default_fallbacks (_tmp0_);
	themed_icon = _tmp1_;
	_tmp2_ = style;
	_tmp3_ = size;
	_tmp4_ = granite_services_icon_factory_load_symbolic_icon_from_gicon (self, _tmp2_, G_TYPE_CHECK_INSTANCE_CAST (themed_icon, g_icon_get_type (), GIcon), _tmp3_);
	result = _tmp4_;
	_g_object_unref0 (themed_icon);
	return result;
}


static void granite_services_icon_factory_class_init (GraniteServicesIconFactoryClass * klass) {
	granite_services_icon_factory_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GraniteServicesIconFactoryPrivate));
	G_OBJECT_CLASS (klass)->finalize = granite_services_icon_factory_finalize;
}


static void granite_services_icon_factory_instance_init (GraniteServicesIconFactory * self) {
	self->priv = GRANITE_SERVICES_ICON_FACTORY_GET_PRIVATE (self);
}


static void granite_services_icon_factory_finalize (GObject * obj) {
	GraniteServicesIconFactory * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GRANITE_SERVICES_TYPE_ICON_FACTORY, GraniteServicesIconFactory);
	_g_object_unref0 (self->priv->icon_theme);
	G_OBJECT_CLASS (granite_services_icon_factory_parent_class)->finalize (obj);
}


/**
     * This class provides an easy way to access symbolic icons.
     */
GType granite_services_icon_factory_get_type (void) {
	static volatile gsize granite_services_icon_factory_type_id__volatile = 0;
	if (g_once_init_enter (&granite_services_icon_factory_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GraniteServicesIconFactoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) granite_services_icon_factory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GraniteServicesIconFactory), 0, (GInstanceInitFunc) granite_services_icon_factory_instance_init, NULL };
		GType granite_services_icon_factory_type_id;
		granite_services_icon_factory_type_id = g_type_register_static (G_TYPE_OBJECT, "GraniteServicesIconFactory", &g_define_type_info, 0);
		g_once_init_leave (&granite_services_icon_factory_type_id__volatile, granite_services_icon_factory_type_id);
	}
	return granite_services_icon_factory_type_id__volatile;
}



